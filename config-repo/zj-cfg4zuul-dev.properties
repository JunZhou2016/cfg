#spring.application.name=gateway-service-zuul
#eureka.client.serviceUrl.defaultZone=http://localhost:8000/eureka/
#zuul.servlet-path=/
server.port=8002
spring.application.name=spring-cloud-zuul
#redis
#spring.session.store-type=redis
#spring.redis.host=localhost
#spring.redis.password=fangshuoit
#spring.redis.port=6379
#此处需要快速熔断的服务，因此此处注释掉和重试相关的属性;
#是否开启重试功能
#zuul.retryable=true
#对当前服务的重试次数
#ribbon.MaxAutoRetries=4
#切换相同Server的次数
#ribbon.MaxAutoRetriesNextServer=0
########################  Redis ###################################
spring.redis.database=0
spring.redis.host=localhost
spring.redis.port=6379
spring.redis.password=
# 连接池最大连接数
spring.redis.pool.max-active=8
spring.redis.pool.max-wait=-1
# 连接池中的最大空闲连接
spring.redis.pool.max-idle=8
# 连接池中的最小空闲连接
spring.redis.pool.min-idle=0
# 连接超时时间（毫秒）
spring.redis.timeout=0
spring.session.store-type=redis
#是否对头部信息敏感;
zuul.sensitive-headers= 
#将头信息下发至下游服务;
zuul.add-host-header=true
#注意
#
#开启重试在某些情况下是有问题的，比如当压力过大，一个实例停止响应时，
#路由将流量转到另一个实例，很有可能导致最终所有的实例全被压垮。
#说到底，断路器的其中一个作用就是防止故障或者压力扩散。
#用了retry，断路器就只有在该服务的所有实例都无法运作的情况下才能起作用。
#这种时候，断路器的形式更像是提供一种友好的错误信息，或者假装服务正常运行的假象给使用者。
#
#不用retry，仅使用负载均衡和熔断，就必须考虑到是否能够接受单个服务实例关闭和eureka刷新服务列表之间带来的短时间的熔断。
#如果可以接受，就无需使用retry。
